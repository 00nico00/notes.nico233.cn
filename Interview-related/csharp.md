## 1.c＃gc的触发条件有哪些，如何避免频繁gc，如何手动控制gc

触发条件：
+ 对象的物理内存较低
+ 托管堆上分配的对象占用的内存超出了可接受阈值
+ 调用 `GC.Collect()` 方法

如何避免频繁 `GC` ：
+ 对于频繁出现消失的物体使用对象池管理
+ 减少 `new` 产生对象的次数
+ 使用公用的对象，即静态成员 `Static` ,但要谨慎使用（例如一个 `List<int>` 含有大量的数据却没有清除一直占用着内存）
+ 如果是在 `unity` 当中，尽量避免使用 `foreach` ，尽量使用 `for`

`Unity` 当中为什么要尽量避免使用 `foreach` ：
`foreach` 内部有迭代器，会导致装箱操作，进而引起频繁的 `GC.Alloc` ，尤其是在 `Update` 当中调用其之后会造成大量的小块垃圾内存，造成垃圾回收操作的提前到来，造成游戏间歇性的卡顿。

如何手动控制 `gc` ：
使用 `GC.Collect()` 方法，可以传入一个 `0` , `1`, `2` 三个数字，以清除第几代的托管堆内存

## 2.什么是异步，为什么要使用异步编程，异步与多线程的关系，task和thread的区别，Unity的协程和Task的区别

## 3.委托的本质是什么，c＃委托的底层实现思路是什么，委托和委托实例和事件三者的关系，为什么要使用委托

